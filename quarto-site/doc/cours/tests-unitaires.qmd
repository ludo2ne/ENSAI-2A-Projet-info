---
title: "Unit Testing"
description: "[Slides](tests-unitaires-slides.html)"
author: "Ludovic Deneuville"
format:
  html:
    toc: true
    toc-location: left
    toc-depth: 2
  revealjs:
    theme: moon
    footer: "[Home](../../index.html) --- [Unit Testing](tests-unitaires.html)"
    slide-number: c/t                    ## collapsed/total
    slide-level: 3
    controls: true
    output-file: tests-unitaires-slides.html
from: markdown+emoji
lightbox: true
---
## Testing
![Source: [CommitStrip](https://www.commitstrip.com/){target="_blank"}](img/commitStrip_tester_ou_non.jpg){style="background-color: white; padding: 10px; border-radius: 5px; display: inline-block"}

### Why Test?
- Car crash tests
- Compliance tests
- Quality tests in industry
- Statistical tests

### In Computer Science
- To verify that your program works
- To detect errors
- To avoid regressions (when you modify code)

::: {.callout-note}
No test is perfect, but it still helps eliminate many errors.
:::

::: {.notes}
Already testing a feature from a developer whose nominal case crashes.
:::

### Definition
A test resembles a scientific experiment.

It examines a hypothesis expressed in terms of three elements:

- Input data
- The object to test
- Expected results

This examination is conducted 

- under controlled conditions 
- with the goal to draw conclusions 
- and ideally, be reproducible.

### Test Coverage
- Percentage of functions tested
- **ONE** quality indicator
- Trend, rather than a reliable value

Be lazy : fewer tests, but useful ones!

::: {.notes}
Number of tested functions over the total number of functions.
Trend because it's easy to test all elementary methods to mechanically increase coverage and set aside tests on more complex methods.
:::

### Types of Tests {.smaller}
There are many different types of tests, here are the main ones:

- **Unit test**
- Functional test
- Load test
- Integration test
- Penetration test
- ...


:::{.notes}
- **Unit test**: tests a function to verify its proper operation
- Functional test: tests the use cases of the software
- Load test: evaluates the system's ability to handle a high volume of data or transactions
- Integration test: verifies that different components or modules of a system interact correctly together
- Penetration test: checks the software's security by searching for vulnerabilities and simulating potential attacks
- ...
:::

## Unit Testing
We will use the `pytest` package to perform our tests in Python.

### A Good Unit Test
- Tests a single functionality
- Isolated
- Reproducible
- Deterministic

::: {.notes}
- Isolated: independent of other tests
  - If you test a method A, which itself calls other methods B, C, D...
  - The test should only be on method A
  - You need to `mock` the behavior of other methods
- Deterministic: always gives the same result
:::

### Method to Test
```{.python filename="operations_mathematiques.py"}
class MathOperations:
    """Mathematical Operations"""
    def divide_five_by(self, nb) -> float:
        """Divides the number 5 by a given number.
        Parameters
        ----------
        nb : float or int
            The number by which 5 will be divided.
        Returns
        -------
        float or None
            The result of dividing 5 by the given number.
            If the number is equal to 0, the method returns None.
        """
        if nb != 0:
            return 5 / nb
        else:
            return None
```

### Test Class
Let's create a test class.

To test the nominal case (="normal" case), we:

- Choose an input number
- Call the `divide_five_by()` method
- Verify that the returned value is equal to the expected value

### Nominal Case
```{.python filename="test_operations_mathematiques.py"}
import pytest
from mathematiques.operations_mathematiques import MathOperations
class TestMathOperations():
    def test_divide_five_by_non_null_nb(self):
        # GIVEN
        nombre = 2
        # WHEN
        resultat = MathOperations().divide_five_by(nombre)
        # THEN
        assert resultat == 2.5
```
::: {.notes}
Is this sufficient?
:::

### Other Cases
But this is not sufficient!

- The method also has another possible return: `None`
- We also need to test this case

```{.python filename="test_operations_mathematiques.py"}
    def test_divide_five_by_zero(self):
        # GIVEN
        nombre = 0
        # WHEN
        resultat = MathOperations().diviser_cinq_par(nombre)
        # THEN
        assert resultat is None
```

### What If...
We call the method with this parameter: `divide_five_by("a")`?

You can also write a test to verify that your method indeed returns a `TypeError` exception in this case.


```{.python filename="test_operations_mathematiques.py"}
    def test_divide_five_by_string(self):
        # GIVEN
        nombre = "a"
        # WHEN / THEN
        with pytest.raises(TypeError):
            MathOperations().diviser_cinq_par(nombre)
```
::: {.notes}
But it is still preferable to check in your method that the parameter is indeed of a numeric type and decide what to do if it is not.
:::

### Key Takeaways
Unit tests:

- Verify that a method does what it is supposed to do
- Test nominal cases, but also edge cases and errors
- A unit test tests ONE and ONLY ONE thing
- As many unit tests as there are possible returns

::: {.notes}
Seen in 1st year:
```{.python}
@pytest.mark.parametrize(
'a, b, resultat_attendu',
[(2, 3, 5),
 (2, 5, 7),
 (3, 4, 7)]
)
```
:::

## Mock
- Simulated object that replaces a real component during tests
- Isolating external dependencies = test code independently
- Simulate complex scenarios like network errors

### Mock - Example
```{.python filename="joueur_service.py"}
class JoueurService:
    def creer(self, pseudo, mdp, age, mail, fan_pokemon) -> Joueur:
        nouveau_joueur = Joueur(
            pseudo=pseudo,
            mdp=hash_password(mdp, pseudo),
            age=age,
            mail=mail,
            fan_pokemon=fan_pokemon,
        )
        creation_ok = JoueurDao().creer(nouveau_joueur)
        if creation_ok:
            return nouveau_joueur
        else:
            return None
```

::: {.notes}
How to predict the behavior of `JoueurDao().creer(nouveau_joueur)`?
:::

### Mock - Example

```{.python filename="test_joueur_service.py"}
from unittest.mock import MagicMock
def test_creer_ok():
    """Successful creation of Joueur"""
    # GIVEN
    pseudo, mdp, age, mail, fan_pokemon = "jp", "1234", 15, "z@mail.oo", True
    JoueurDao().creer = MagicMock(return_value=True)
    # WHEN
    joueur = JoueurService().creer(pseudo, mdp, age, mail, fan_pokemon)
    # THEN
    assert joueur.pseudo == pseudo
```

## Test-Driven Development (TDD)

### When to Test?

::: {.fragment}
At the beginning!

::: {.callout-tip}
The earlier you test, the more effective and less costly the tests are!
:::

:::

### Test-Driven Development
The best practice:

1. Create the tests

2. Code the function

### Logic

:::{.callout-note}
It may seem a bit strange/strict

BUT you have done your functional anaylsis and system design

You KNOW what there is and what shape it has!
:::

When you code a function, you know before you start:

- What the input parameters will be
- What results you expect as output
- So you already know what to test!

### TDD Practice
- ✅ Improvement of code quality
- ✅ Reduction of bugs
- ❌ then ✅ Time
- ❌ Maintenance of tests

::: {.callout-important}
Advantages >>> Disadvantages
:::


::: {.notes}
The practice of TDD has the big advantage of forcing us to write tests and take the time to do things well. To adhere to TDD, you really have to force yourself at the beginning, but ultimately this practice is very beneficial.
Otherwise, if we write the function first, once we're done, there's a 90% chance we'll say to ourselves: "It works, no need to test..." And that's not good!!!
:::

### Project tip

Designate the Test Police (or the Quality Police)

Why ?

- Ensure all important methods are tested
- Maintain consistency in testing and documentation
- Promote the test-first thinking

Benefits on team spirit

- Contribute to code quality without coding A-Z
- One person has an idea of the whole architecture and the pain points
- Easier to review when it's not your code

