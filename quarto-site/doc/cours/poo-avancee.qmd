---
title: "Advanced Object-Oriented Programming"
description: "[Slides](poo-avancee-slides.html)"
author: "Ludovic Deneuville, Rémi Pépin"
format:
  html:
    toc: true
    toc-location: left
    toc-depth: 2
  revealjs:
    theme: moon
    footer: "[Home](../../index.html) --- [Advanced OOP](poo-avancee.html)"
    slide-number: c/t                    ## collapsed/total
    slide-level: 3
    controls: true
    output-file: poo-avancee-slides.html
from: markdown+emoji
lightbox: true
---
## Outline
1. Advanced OOP Concepts
   - Recap
   - Abstract Classes
   - Bridge Pattern
2. Software Engineering
   - Definition
   - Single Responsibility Principle
   - Design Patterns

## A Few Reminders
The three principles of object-oriented programming:

- **Encapsulation:** an object contains **attributes** and **methods**.

- **Inheritance:** an object can **inherit** attributes and methods from another class to **redefine** them. It can also add other attributes/methods.

- **Polymorphism:** a method can be associated with **different code** depending on the parameters passed or the object it belongs to.


::: {.notes}
These are the three principles that object-oriented programming brings. They are presented in order of "simplicity." The quality of your code will depend on your mastery and application of these principles. It takes time to fully understand them.
- Attribute: what it is
- Method: what it can do
- Inheritance: new capabilities (e.g., Doctor -> Surgeon)
- Polymorphism: 2 types (list of Animal.speak(sick=True))
:::


### An Example to Illustrate
Automatic data processing application:

- Multiple data sources: surveys, web scraping, administrative files, etc.
- Multiple data formats: csv, xml, json, etc. (*we'll come back to this*)
- Multiple processing algorithms: exploratory statistics, regression, "machine learning," etc.

::: {.notes}
Fundamentally, it's a fairly simple application.
:::

### Example of a Class Diagram
![](img/class_diagram_no_poo.png)


::: {.notes}
Do you see anything to correct?
Will the *process()* method be the same for survey and census?
```{.python}
def process(self):
  if self.type == "census":
    ...
  elif
    ...
```
:::

### An Example with Inheritance
![](img/class_diagram_poo1.png)


::: {.notes}
The `Source` class allows centralizing common attributes and defining common methods, but these methods will be overridden by child classes.
Thanks to polymorphism, I have different behavior, but the code remains clear, with a part common to all file types and a specific part.
Code in the OOP example folder.
What do you think of the Source class?
:::

### Abstract Classes

**Abstract Class:** a class whose implementation is **not complete** and which is **not instantiable**. 

Allows passing a **contract**. Child classes will have to implement what is missing.

**Advantages:**

- We know what child classes must do 👍
- We can generate code 🙏
- Limits the risk of error!! 👌


::: {.notes}
Some objects do not need to be fully implemented or instantiated. Often, it's for abstract concepts.
Recap: class, object, abstract (Vehicle)
:::

### For Example
![](img/class_diagram_poo_abstract_class.png)


::: {.notes}
For you, this might seem like a minor change (especially because of Python), but this change allows manipulating abstraction instead of implementations and having clean code (you'll do this in the practical work).
`v = Vehicle("red")` -> this no longer works
Abstract method *custom_process*
:::

### And in Python?

- No native support for abstract classes 😱
- Abstract Base Classes (abc) module to solve the problem 🦾
- Already included in your Python distribution 😌
  - **Step 1:** Import the module 🧳
  - **Step 2:** Inherit from `ABC` 👨‍👩‍👧‍👦
  - **Step 3:** Define abstract methods 📝
  - **Step 4:** ???
  - **Step 5:** Profit 💰💰


::: {.notes}
Step 4: implement the abstract methods in child classes
Another major drawback of Python is its dynamic typing.
Python will type objects at runtime, not at compile time. This doesn't allow for as many tools as in other languages. But you can use docstrings to type your objects.
:::

### What If We Added Data Formats?

Currently, 3 data formats in our application:

- **CSV:** Comma Separated Values (tabular)
- **XML:** eXtended Markup Language (tag format)
- **JSON:** JavaScript Object Notation (key-value format)

::: {.notes}
We'll come back in more detail to the different formats.
Back to 2 slides ago: if we do the same and use inheritance for the format
:::

### For Example
![](img/class_diagram_poo_file_format.png)
Do you see a problem?


::: {.notes}
It grows exponentially
:::

### The Power of OOP

- Currently 4 * 3 "concrete" classes to define 😱
- Reading the format is dependent on the source 😵

**BUT**

- We can externalize this processing! 😌
- Aggregation relationship 🤯

::: {.notes}
It's important to understand
:::

### The Bridge Pattern
![](img/class_diagram_poo_bridge_pattern.png)


::: {.notes}
:::

### Work Smart, Not Hard

- **Composition + inheritance:** 9 classes 😎
- **Inheritance:** 17 classes 😫
- We can easily add types and formats 🥳


::: {.callout-important title="Bridge Pattern"}
Breaking down a large class into a group of small classes with their own hierarchy that must then be assembled.
:::

### In Summary

- Use the power of OOP 💣
- Prefer specific objects (inheritance) over `if/elif/else` 🐱‍🏍
- Abstract classes are blueprints for future classes 👷‍♀️👷‍♂️
- OOP allows creating more readable, scalable, and maintainable code 👑

## Software Engineering
<iframe src="https://giphy.com/embed/bU3bD2rsKq02Q" width="600" height="500" frameBorder="0" class="no-print giphy-embed" allowFullScreen></iframe>


::: {.notes}
We're going to take it up a notch.
:::

### What is Software Engineering?
- Observation: coding blindly does not result in a quality application.
- But stacking bricks blindly does not result in a house, even if you have a plan.
- Need to plan, document, test...


::: {.notes}
And this part will be the second part of the intermediary report.
:::

### Why It's Important: Parallel with Building a House
![](https://media.giphy.com/media/l2JeblbdfRL0i2qOI/giphy.gif)

### Why It's Important: Parallel with Building a House

- You have the construction plan for a house (provided by the architect)
- But implementing this plan requires technical knowledge
- Need to redraw diagrams for specific areas (arches, stairs, etc.)
- **This is not wasted time!**
**Writing quality code is like doing precision craftsmanship; it requires tools, experience, and methods.**


::: {.notes}
Some even say we should spend more time analyzing than coding. This is debatable, but it shows how important the analysis phase (how to code the functions) is!
:::

### Some Basic Principles

- Decompose a program into simple **coherent** modules
- Modules **expose** methods that can be used/overridden by other modules but remain protected from unintended modifications
- Each module should be a **black box** for others
- If we keep the same **inputs/outputs**, we can change a module without risk
- Prefer abstractions + inheritance over `if/elif/else`

::: {.notes}
Module architecture != Python module.
Layer is when we have stacked modules (a lot of vocabulary to assimilate at once).
Draw a diagram with and without. Explain that it's the job of a business object to say how it is displayed and how it is stored.
Similarly, it's not the job of a view to perform a calculation. However, a view can request it.
Emphasize "layer independence." Theoretically, if two people work on 2 layers and agree on how they communicate, the work can be done in parallel.
:::

### A Mantra

::: {.callout-important}
**Low coupling, high cohesion**
:::

- **Low inter-class coupling:** modifying one class should impact others as little as possible.
- **High intra-class cohesion:** each class should be a coherent set of attributes and methods.


::: {.notes}
Keep this in mind whenever you write code (R, SAS, etc.). Make the most unit functions possible to test and replace them easily. Divide your code into several files to make it more reusable. It's not easy at first, but you have to think about it.
:::

### Why Respect Low Coupling, High Cohesion?
- Teamwork 🦸‍♀️🧙‍♂️👨‍💼👩‍🔬
- Code readability 📖
- Debugging 🐞
**Limit the risk of errors when modifying code (avoid spaghetti code) 🍝**

::: {.notes}
"Spaghetti": very chaotic code where everything communicates with everything, and each piece of code does a bit of everything. You have to take a piece of code and manually trace it back by "pulling" on it. It becomes unmanageable when there are more than 1000 lines of code (and different languages).
:::

### Revisiting the Bridge Pattern
![](img/class_diagram_poo_bridge_pattern.png)

::: {.notes}
I'll show the diagram again for a few seconds
:::

### Revisiting the Bridge Pattern

- The "Source" part handles processing related to the source.
- The "File" part handles file reading.
- Only inputs/outputs matter.
- We can add a "Processing" part for additional processing.
- No unnecessary `if/elif/else`.
**Each part of our code handles only one thing**


::: {.notes}
Advantages:
- Easier code reading.
- In case of a bug, it's easy to find the culprit.
- We can easily distribute the work.
:::

### Design Patterns: Definition

> "In computer science, and more specifically in software development, a design pattern is a characteristic arrangement of modules, recognized as a best practice in response to a software design problem. It describes a standard solution, usable in the design of different software."
> — [Source](https://en.wikipedia.org/wiki/Software_design_pattern)

### Design Patterns: In a Nutshell

- Best practices
- Standard solutions to design problems
- Robust solutions
- Independent of technology
- Independent of the business
> **Is a tool that is there to help you**

::: {.notes}
Additionally, they provide a common vocabulary.
It's faster to say "you should use a bridge" than "you should make a second class hierarchy and assemble these hierarchies."
:::

### Design Patterns: Example

**Recurring Problem:**

- Creating complex objects that are a composition of independent characteristics
- In other words: decouple abstraction from its implementation so they can vary independently

### Design Patterns: Example
![](img/class_diagram_poo_bridge_pattern_advanced.png)

::: {.notes}
By adding statistical methods
:::

### In Summary

- Creating a complex application requires complex code 🧩
- Without a design phase, we're heading for trouble 🧱
- There are ready-made solutions to common problems 🧰

::: {.callout-important}
Low coupling, high cohesion
:::
