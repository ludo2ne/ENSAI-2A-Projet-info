---
title: "Programation orientÃ©e Objet - AvancÃ©e"
description: "[Slides](poo-avancee-slides.html)"
author: "Ludovic Deneuville, RÃ©mi PÃ©pin"
format: 
  html:
    toc: true
    toc-location: left
    toc-depth: 2
  revealjs:
    theme: moon
    footer: "[Home](../../index.html) --- [POO AvancÃ©e](poo-avancee.html)"
    slide-number: c/t                    ## collapsed/total
    slide-level: 3
    controls: true
    output-file: poo-avancee-slides.html
from: markdown+emoji
lightbox: true
---

## Plan

1. Notions avancÃ©es de POO
    - Rappels
    - Classes abstraites
    - Bridge pattern
2. GÃ©nie logiciel
    - DÃ©finition
    - Single responsibility principle
    - Design patterns

## Quelques rappels

Les trois principes de l'objet :

- **Encapsulation :** un objet va contenir des **attributs** et des **mÃ©thodes**.
- **HÃ©ritage :** un objet peut **hÃ©riter** des attributs et mÃ©thodes d'une autre classe pour les **redÃ©finir**. Il peut Ã©galement ajouter d'autres attributs/mÃ©thodes.
- **Polymorphisme :** une mÃ©thode peut Ãªtre associÃ©e Ã  un **code diffÃ©rent** en fonction des paramÃ¨tres passÃ©s ou de l'objet auquel elle appartient.

::: {.notes}
Ce sont les trois principes qu'apporte la programmation orientÃ©e objet. Ils sont prÃ©sentÃ©s par ordre de "simplicitÃ©". La qualitÃ© de votre code va dÃ©pendre de votre maÃ®trise et application de ces principes. Cela prend du temps pour bien les comprendre.

- Attribut : ce qu'il est
- MÃ©thode : ce qu'il peut faire
- HÃ©ritage : Nouvelles capacitÃ©s (ex : MÃ©decin -> Chirurgien)
- Polymorphisme : 2 types (liste d'Animal.parler(malade=True))
:::

### Un exemple pour illustrer cela

Application de traitements automatiques des donnÃ©es :

- Plusieurs sources de donnÃ©es : enquÃªtes, webscraping, fichiers administratifs, ...
- Plusieurs formats de donnÃ©es : csv, xml, json, ... (*on en reparlera*)
- Plusieurs algorithmes de traitement : statistique exploratoire, rÃ©gression, "machine learning", ...

::: {.notes}
Fondamentalement, c'est une application assez simple.
:::

### Exemple de diagramme de classe

![](img/class_diagram_no_poo.png)

::: {.notes}
Voyez-vous des choses Ã  corriger ?  
Est-ce que la mÃ©thode *process()* sera la mÃªme pour survey et census ?

```{.python}
def process(self):
  if self.type = "census":
    ...
  elif
    ...
```

:::

### Un exemple avec de l'hÃ©ritage

![](img/class_diagram_poo1.png)

::: {.notes}
La classe `Source` permet de centraliser des attributs communs et de dÃ©finir des mÃ©thodes communes, mais ces mÃ©thodes vont Ãªtre surchargÃ©es par les classes filles.  
GrÃ¢ce au polymorphisme, j'ai un comportement diffÃ©rent mais le code reste clair, avec une partie commune Ã  tous les types de fichiers et une partie spÃ©cifique.

Code dans le dossier exemple POO.

Que pensez-vous de la classe Source ?
:::

### Les classes abstraites

> **Classe Abstraite :** classe dont l'implÃ©mentation n'est **pas complÃ¨te** et qui n'est **pas instantiable**. Permet de passer un **contrat**. Les classes filles vont devoir implÃ©menter ce qu'il manque.

**Avantages :**

- Nous savons ce que les classes filles doivent faire ğŸ‘
- Nous pouvons gÃ©nÃ©rer du code ğŸ™
- Limite le risque d'erreur !! ğŸ‘Œ

::: {.notes}
Certains objets n'ont pas besoin d'Ãªtre implÃ©mentÃ©s complÃ¨tement ni de pouvoir Ãªtre instantiÃ©s. Souvent, c'est pour des notions abstraites.  

Rappels : classe, objet, abstrait (Vehicule)
:::

### Par exemple

![](img/class_diagram_poo_abstract_class.png)

::: {.notes}
Pour vous, cela peut sembler marginal comme changement (surtout Ã  cause de Python), mais ce changement permet de manipuler l'abstraction au lieu des implÃ©mentations et d'avoir un code propre (vous ferez Ã§a en TP).

`v = Vehicule("rouge")` -> Ã§a marche plus

MÃ©thode *custom_process* abstraite
:::

### Et en Python ?

- Pas de gestion native des classes abstraites ğŸ˜±
- Module Abstract Base Classes (abc) pour rÃ©soudre le problÃ¨me ğŸ¦¾
- DÃ©jÃ  inclus dans votre distribution Python ğŸ˜Œ
  - **Step 1 :** Importer le module ğŸ§³
  - **Step 2 :** HÃ©riter de `ABC` ğŸ‘¨â€ğŸ‘©â€ğŸ‘§â€ğŸ‘¦
  - **Step 3 :** DÃ©finir les mÃ©thodes abstraites ğŸ“
  - **Step 4 :** ???
  - **Step 5 :** Profit ğŸ’°ğŸ’°

::: {.notes}
Step 4 : implÃ©menter les mÃ©thodes abstraites dans les classes filles

L'autre gros dÃ©faut de Python est son typage dynamique.

Python va typer les objets au runtime, et pas au compile time. Cela ne permet pas d'avoir autant d'outils que dans d'autres langages. Mais vous pouvez utiliser les docstrings pour typer vos objets.
:::

### Et si on ajoutait les formats de donnÃ©es ?

Actuellement, 3 formats de donnÃ©es dans notre application :

- **CSV :** Comma Separated Values (tabulaire)
- **XML :** eXtended Markup Language (format Ã  balise)
- **JSON :** JavaScript Object Notation (format clef-valeur)

::: {.notes}
On reviendra plus en dÃ©tail sur les diffÃ©rents formats.

Retour 2 slides avant : si on fait pareil et qu'on utilise l'hÃ©ritage pour le format
:::


### Par exemple

![](img/class_diagram_poo_file_format.png)

Voyez-vous un problÃ¨me ?

::: {.notes}
CÃ  grossit de maniÃ¨re exponentielle
:::


### La puissance de la POO

- Actuellement 4 * 3 classes "concrÃ¨tes" Ã  dÃ©finir ğŸ˜±
- La lecture du format est dÃ©pendante de la source ğŸ˜µ

**MAIS**

- On peut externaliser ce traitement ! ğŸ˜Œ
- Relation d'agrÃ©gation ğŸ¤¯

::: {.notes}
Il faut bien comprendre
:::

### Le bridge pattern

![](img/class_diagram_poo_bridge_pattern.png)

::: {.notes}
:::

### Work smart, not hard

- **Composition + hÃ©ritage :** 9 classes ğŸ˜
- **HÃ©ritage :** 17 classes ğŸ˜«
- On peut facilement ajouter des types et des formats ğŸ¥³

::: {.callout-important title="Pattern Bridge"}
DÃ©coupage d'une grosse classe en un groupe de petites classes avec leur propre hiÃ©rarchie qu'il faut ensuite assembler.
:::

### Pour rÃ©sumer

- Utiliser la puissance de la POO ğŸ’£
- PrÃ©fÃ©rer les objets spÃ©cifiques (hÃ©ritage) au `if/elif/else` ğŸ±â€ğŸ
- Les classes abstraites sont des plans pour les futures classes ğŸ‘·â€â™€ï¸ğŸ‘·â€â™‚ï¸
- La POO permet de crÃ©er des codes plus lisibles, Ã©volutifs et maintenables ğŸ‘‘

## Le gÃ©nie logiciel

<iframe src="https://giphy.com/embed/bU3bD2rsKq02Q"  width="600" height="500" frameBorder="0" class="no-print giphy-embed" allowFullScreen></iframe>

::: {.notes}
On va aller un cran au-dessus.
:::



### C'est quoi le gÃ©nie logiciel ?

- Un constat : coder bÃªtement ne permet pas de faire une application de qualitÃ©.
- Mais empiler des briques bÃªtement ne permet pas de faire une maison, mÃªme si on a un plan.
- Besoin de planifier, de documenter, de tester...

::: {.notes}
Et cette partie sera la seconde du rapport intermÃ©diaire.
:::

### Pourquoi c'est important : parallÃ¨le avec la construction d'une maison

![](https://media.giphy.com/media/l2JeblbdfRL0i2qOI/giphy.gif)

### Pourquoi c'est important : parallÃ¨le avec la construction d'une maison

- Vous avez le plan de construction d'une maison (fourni par l'architecte)
- Mais implÃ©menter ce plan demande des connaissances techniques
- Besoin de refaire des schÃ©mas pour des zones prÃ©cises (arches, escaliers, ...)
- **Ce n'est pas du temps perdu !**

**Faire du code de qualitÃ© c'est comme faire de l'artisanat de prÃ©cision, cela demande outils, expÃ©rience et mÃ©thodes.**

::: {.notes}
Certains disent mÃªme qu'on devrait passer plus de temps Ã  analyser qu'Ã  coder. Sujet Ã  dÃ©bat, mais cela montre bien que la phase d'analyse (comment je code les fonctions) est super importante !
:::


### Quelques principes de base

- DÃ©composition d'un programme en modules simples **cohÃ©rents**
- Les modules **exposent** des mÃ©thodes utilisables/surchageables par d'autres modules mais restent protÃ©gÃ©s aux modifications non prÃ©vues
- Chaque module doit Ãªtre une **boÃ®te noire** pour les autres
- Si on garde les mÃªmes **entrÃ©es/sorties**, on peut changer un module sans risque
- PrivilÃ©gier abstractions + hÃ©ritage plutÃ´t que `if/elif/else`

::: {.notes}
Module architecture != module Python.
Couche, c'est quand on a des modules empilÃ©s (beaucoup de vocabulaire Ã  assimiler d'un coup). 

Faire un dessin avec et sans. Expliquer que c'est le boulot d'un objet mÃ©tier de dire comment il s'affiche et comment on le stocke.

Pareil c'est pas le boulot d'une vue de faire un calcul. Par contre une vue peut demander.
Bien insister sur "l'indÃ©pendance des couches". ThÃ©oriquement si deux personnes travaillent sur 2 couches et se sont mises d'accord sur comment elles communiquent le travail peut se faire en parallÃ¨le.
:::

### Un mantra

::: {.callout-important}
**Faible couplage, forte cohÃ©rence**
:::


- **Faible couplage inter-classes :** modifier une classe doit impacter les autres le moins possible.
- **Forte cohÃ©rence intra-classe :** chaque classe doit Ãªtre un ensemble cohÃ©rent d'attributs et de mÃ©thodes.

::: {.notes}
Gardez Ã§a en tÃªte dÃ¨s que vous faites du code (R, SAS, etc.). Faites des fonctions les plus unitaires possible pour pouvoir les tester et les remplacer facilement. Divisez votre code en plusieurs fichiers pour le rendre rÃ©utilisable plus facilement. Ce n'est pas facile au dÃ©but, mais il faut y penser.
:::

### Faible couplage, forte cohÃ©rence : pourquoi le respecter ?

- Travail en groupe ğŸ¦¸â€â™€ï¸ğŸ§™â€â™‚ï¸ğŸ‘¨â€ğŸ’¼ğŸ‘©â€ğŸ”¬
- LisibilitÃ© du code ğŸ“–
- DÃ©bogages ğŸ

**Limiter les risques d'erreur quand on modifie le code (Ã©viter l'assiette de spaghetti) ğŸ**

::: {.notes}
"Spaghetti" : code trÃ¨s chaotique oÃ¹ tout communique avec tout, et oÃ¹ chaque morceau de code fait un peu de tout. Il faut prendre un bout de code et le remonter Ã  la main en "tirant" dessus. Cela devient ingÃ©rable quand il y a plus de 1000 lignes de code (et diffÃ©rents langages).
:::


### Retour sur le bridge pattern

![](img/class_diagram_poo_bridge_pattern.png)

::: {.notes}
Je remontre le schÃ©ma quelques secondes
:::

### Retour sur le bridge pattern

- La partie "Source" gÃ¨re les traitements liÃ©s Ã  la source.
- La partie "Fichier" gÃ¨re la lecture de fichier.
- Seules les entrÃ©es/sorties comptent.
- On peut ajouter une partie "Traitement" pour des traitements supplÃ©mentaires.
- Pas de `if/elif/else` inutiles.

**Chaque partie de notre code s'occupe d'une seule chose**

::: {.notes}
Avantages :

- Lecture du code facilitÃ©e.
- En cas de bug, facile de trouver le coupable.
- On peut rÃ©partir le travail facilement.
:::

### Les design patterns : dÃ©finition

> â€œEn informatique, et plus particuliÃ¨rement en dÃ©veloppement logiciel, un patron de conception (souvent appelÃ© design pattern) est un arrangement caractÃ©ristique de modules, reconnu comme bonne pratique en rÃ©ponse Ã  un problÃ¨me de conception d'un logiciel. Il dÃ©crit une solution standard, utilisable dans la conception de diffÃ©rents logiciels.â€  
> â€” [Source](https://fr.wikipedia.org/wiki/Patron_de_conception)


### Les design patterns : in a nutshell

- Bonnes pratiques
- Solutions standards Ã  des problÃ¨mes de conception
- Solutions robustes
- IndÃ©pendants de la technologie
- IndÃ©pendants du mÃ©tier

> **Est un outil qui est lÃ  pour vous aider**

::: {.notes}
En plus ils apportent un vocabulaire commun.  
Il est plus rapide de rÃ©pondre "tu devrais utiliser un bridge" que "tu devrais faire une seconde hiÃ©rarchie de classes et assembler ces hiÃ©rarchies"
:::

### Les design patterns : exemple

**ProblÃ¨me rÃ©curent :**

- CrÃ©er des objets complexes qui sont une composition de caractÃ©ristiques indÃ©pendantes
- Dit autrement : dÃ©coupler l'abstraction de son implÃ©mentation pour qu'elles puissent varier indÃ©pendamment


### Les design patterns : exemple

![](img/class_diagram_poo_bridge_pattern_advanced.png)

::: {.notes}
En ajoutant les mÃ©thodes stats
:::


### Pour rÃ©sumer

- Faire une application complexe demande un code complexe ğŸ§©
- Sans phase de conception on va dans le mur ğŸ§±
- Il existe des solutions prÃªtes Ã  l'emploi Ã  des problÃ¨mes courants ğŸ§°

::: {.callout-important}
Faible couplage, forte cohÃ©rence
:::

