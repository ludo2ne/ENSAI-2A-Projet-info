---
title: "Sujets de projet informatique 2A"
description: "Sujets 2025-2026"
format:
  html:
    toc: true
    toc-location: left
    toc-depth: 2
from: markdown+emoji
---


## ensaiGPT

Tuteur : Adrien Lacaille

### Pr√©sentation

Vous utilisez tous ChatGPT, mais avez-vous d√©j√† essay√© de le cr√©er vous-m√™me ?
Ce projet vous propose de concevoir votre propre assistant conversationnel "ensaiGPT", une application dans laquelle chaque utilisateur pourra se connecter, discuter avec un agent intelligent, et retrouver ses anciennes conversations comme s'il s'agissait d'un carnet de bord interactif.

Chaque √©tudiant pourra personnaliser l'agent : ton formel ou d√©contract√©, r√©ponses synth√©tiques ou tr√®s d√©taill√©es, style humoristique ou professionnel‚Ä¶ C'est vous qui d√©cidez de son comportement.

### Fonctionnalit√©s de base

- F1 : Cr√©ation d'un utilisateur avec authentification. Chaque utilisateur doit cr√©er un compte (login simple avec mot de passe) pour acc√©der √† son espace personnel.
- F2 : Cr√©ation et gestion de conversations. Un utilisateur peut d√©marrer une conversation avec l'agent, voir l'historique de ses conversations, et reprendre une conversation interrompue.
- F3 : Recherche dans les conversations pass√©es. Permettre √† l'utilisateur de rechercher des messages ou r√©ponses par mot-cl√© ou date dans ses conversations archiv√©es.
- F4 : Personnalisation de l'agent conversationnel. L'utilisateur peut configurer le comportement du bot via un prompt syst√®me (ex : ton formel / humour / r√©sum√© / t√¢che sp√©cifique).

### Fonctionnalit√©s optionnelles

- FO1 : Mode collaboratif. Plusieurs utilisateurs peuvent participer √† une m√™me conversation (ex : groupe projet, bin√¥me).
- FO2 : Tableau de bord utilisateur. Affichage de statistiques personnalis√©es (nombre de conversations, messages √©chang√©s, sujets les plus fr√©quents, temps pass√©, etc.)
- FO3 : Export de conversations. Possibilit√© d'exporter une conversation en texte simple pour archivage ou pr√©sentation.


---

## Shotgun

Tutrice : Raya Berova

### Pr√©sentation

Ce projet a pour but de cr√©er une application permettant au BDE de g√©rer les inscriptions √† un √©v√©nement (Chartres, WEI, Gala...).  
Chaque √©v√©nement, cr√©√© par un administrateur, propose plusieurs choix de cr√©neaux de bus aller et retour, avec une capacit√© maximale pour chaque cr√©neau et une capacit√© maximale globale pour l'√©v√®nement.

Chaque participant peut s'inscrire √† l'√©v√®nement en s√©lectionnant ses cr√©neaux de bus et en pr√©cisant s'il boit ou non.  
Un mail de confirmation est automatiquement envoy√© apr√®s inscription, contenant un r√©capitulatif des bus choisis, combien il doit payer et comment, ainsi qu'un code de r√©servation.

L'application sera r√©alis√©e en Python, en utilisant la POO, la gestion d'une base de donn√©es PostgreSQL, une couche DAO, et des envois d'email via une API (Brevo).

### Fonctionnalit√©s de base

- F1 : Cr√©ation d'un compte admin
- F2 : Cr√©ation d'un √©v√©nement par un admin (titre, cr√©neaux de bus aller/retour avec capacit√©)
- F3 : Inscription d'un participant √† un √©v√©nement
- F4 : Lister tous les √©v√©nements auxquels le client peut s'inscrire
- F5 : G√©n√©ration d'un code de r√©servation unique et envoi d'un mail de confirmation
- F6 : Pour les admin, avoir la liste des inscrits en temps r√©el √† l'√©v√®nement
- F7 : Suppression d'une r√©servation √† partir du code de r√©servation
- F8 : Gestion des capacit√©s maximales des cr√©neaux de bus et des √©v√®nements

### Fonctionnalit√©s optionnelles

- FO1 : Cr√©ation facultative de compte client pour pr√©-remplissage √† la prochaine inscription
- FO2 : Modification d'une r√©servation √† partir du code de r√©servation
- FO3 : Frontend simple pour les admins/participants
- F05 : Afficher des statistiques sur le nombre d'inscrits
- F06 : Envoyer des rappels par mail pour les paiements
- F07 : D√©ployer l'application
- F08 : Envoyer un mail d'alerte √† tous les clients lorsqu'un nouvel √©v√©nement est cr√©√©

### Conseils / Outils ...

- API **Brevo** pour l'envoi d'emails
- **Langage** : Python
- **Gestion de version** : Git
- **Tests** : `pytest`
- **Base de donn√©es** : PostgreSQL
- **Backend API** : FastAPI



## FuelTrack : Analyse interactive des prix des carburants en France

Tuteur : Anas KNEFATI

### Pr√©sentation

Le projet FuelTrack a pour objectif de d√©velopper une application en ligne de commande (CLI) d√©di√©e √† l'analyse des prix des carburants en France. Cette application s'appuie sur les donn√©es ouvertes fournies par l'API officielle <https://transport.data.gouv.fr/datasets/prix-des-carburants-en-france-flux-quotidien-1>{target="_blank"}

L'ambition est de construire un pipeline complet, allant du t√©l√©chargement quotidien des donn√©es √† leur traitement, leur analyse et leur visualisation graphique. L'outil permettra √† l'utilisateur de suivre l'√©volution des prix des carburants (Gazole, SP95, E85, etc.) et d'identifier les meilleures opportunit√©s d'approvisionnement.

Vous avez toutefois la libert√© de d√©velopper une interface graphique suppl√©mentaire si vous le souhaitez, en prenant en compte la complexit√© et le temps de d√©veloppement. Dans tous les cas, un outil fonctionnel en CLI doit √™tre fourni.


### Fonctionnalit√©s de base

- F1 : **T√©l√©chargement et extraction des donn√©es**
Automatiser le t√©l√©chargement quotidien des fichiers compress√©s (XML) via l'API. Extraire et stocker localement les donn√©es pour analyse.
- F2 : **Parsing et stockage des donn√©es**
Impl√©menter un parser XML pour extraire les champs que vous jugez essentiels dans votre d√©veloppement. Stocker les donn√©es dans une base de donn√©es locale.
- F3 : **Analyse temporelle des prix**
Permettre le calcul de l'√©volution du prix moyen national d'un carburant donn√© sur une p√©riode d√©finie (par exemple : 7 jours) et afficher les r√©sultats sous forme de graphiques 
- F4 : **Recherche des meilleurs prix dans une commune donn√©e**
Pour la date la plus r√©cente disponible, permettre √† l'utilisateur de rechercher les trois stations les moins ch√®res dans une commune sp√©cifi√©e (code postal), pour un type de carburant donn√©.
- F5: **Gestion des utilisateurs et des acc√®s**
Mettre en place un syst√®me d'authentification avec plusieurs niveaux d'acc√®s :
    - *User* : acc√®s en lecture seule pour consulter les analyses et les visualisations.
    - *Admin* : acc√®s complet incluant la gestion des donn√©es (modification, suppression), le suivi des activit√©s, ainsi que la gestion des comptes utilisateurs, r√¥les et configuration de l'application.


### Fonctionnalit√©s optionnelles

- FO1 : **Comparaison multi-carburants**
Permettre la comparaison simultan√©e de l'√©volution des prix de plusieurs carburants sur un m√™me graphique.
- FO2 : **Export des r√©sultats d'analyse**
Offrir la possibilit√© d'exporter les donn√©es analys√©es dans diff√©rents formats : CSV, JSON ou Excel.
- FO3 : **Fonctionnalit√© libre**
Proposez une fonctionnalit√© originale et pertinente, que vous estimez utile dans le cadre du projet.
- FO4 : **Recherche des meilleurs prix autour d'une adresse**
Permettre √† l'utilisateur d'entrer une adresse et de rechercher les prix les plus bas dans un rayon d√©fini.

### Conseils / Outils 
- **Langage** : Python  
- **Traitement des donn√©es** : Pandas  
- **Visualisation** : Matplotlib / Seaborn / Plotly  
- **Parsing & compression** : `zipfile`, `xml.etree.ElementTree`  
- **Base de donn√©es** : PostgreSQL  
- **S√©curit√©** : bcrypt, sessions/tokens  
- **Gestion de version** : Git  
- **R√©daction de tests unitaires** : avec `pytest`


## Mus'IA : G√©n√©rateur de playlists qui correspondent √† vos envies et √† vos id√©es

**Tutrice** : Apolline Gu√©rineau

### Pr√©sentation

Trouver la playlist parfaite qui correspond vraiment √† votre humeur, ce n'est pas toujours facile.
Mus'IA vous permettra de d√©crire une ambiance ou une humeur avec vos propres mots, comme ¬´ soleil et plage ¬ª ou ¬´ amiti√© ¬ª, et g√©n√®rera une playlist de chansons dont les paroles collent √† votre demande. Gr√¢ce √† l'intelligence artificielle, Mus'IA analyse le sens des paroles pour cr√©er une s√©lection musicale unique et personnalis√©e.

Ce projet propose de g√©n√©rer automatiquement des playlists musicales √† partir d'une requ√™te utilisateur exprim√©e en langage naturel (ex : _¬´ aventure et d√©couverte ¬ª_). Le syst√®me s'appuie sur un mod√®le de traitement du langage pour repr√©senter les paroles des chansons sous forme d'embeddings vectoriels (vecteurs de nombres), permettant de calculer leur similarit√© avec la requ√™te de l'utilisateur.
Un outil en CLI permettra √† l'utilisateur de se servir de l'application.

### Fonctionnalit√©s de base

- **F1** : Ajout de chansons dans la base avec nom, artiste, paroles, ann√©e, et calcul automatique des embeddings.
- **F2** : Requ√™te utilisateur en langage naturel pour g√©n√©rer une playlist (via recherche par similarit√© s√©mantique).
- **F3** : Cr√©ation de playlists personnalis√©es (ajout, suppression, consultation).
- **F4** : Endpoints FastAPI pour interagir avec les chansons et playlists depuis l'interface CLI 

### Fonctionnalit√©s optionnelles

- **FO1** : Obtenir les paroles des chansons √† partir de leur nom et artiste(s) via une API externe.
- **FO2** : Enrichir les chansons en base avec des informations compl√©mentaires (album, ann√©e, tempo, etc) via une/des API externes. 
- **FO3** : Permettre √† l'utilisateur d'ajouter des filtres (ann√©e, artiste, genre, langue, etc.) pour affiner la playlist g√©n√©r√©e 
- **FO4** : Permettre d'exporter les playlists cr√©√©es en fichiers compatibles avec des players externes (ex : CSV, JSON, ou int√©gration Spotify).


### Conseils / Outils

- Pour le mod√®le d'embeddings :
    - Utiliser `sentence-transformers` de la biblioth√®que Hugginface avec un mod√®le l√©ger comme `all-MiniLM-L6-v2` pour g√©n√©rer les embeddings - le mod√®le ainsi qu'un exemple de script pour l'utiliser pourront vous √™tre fournis
    - Ou bien utiliser OpenWebUI sur le SSPCloud
- Une API pour obtenir les paroles : LRCLIB's API, mais d'autres existent !



## MagicSearch: Semantic Search for Magic Cards

Supervisor: Gaspard Ferey

### Overview

**Magic: The Gathering** is a popular trading card game built around the mechanic of constructing your own deck. With more than 50,000 cards published since 1993, finding the one you need can quickly become overwhelming... unless you have the right tool!

üí° Traditional search engines let you filter by name, color, or type, but it's often the **text description** of a card that reveals its true purpose. **MagicSearch** offers an intelligent **semantic search** engine that understands your queries in natural language, even if you don't know the exact name of the card.

Example:

- üîé *Enchantement qui accorde le vol √† une cr√©ature et permet de piocher des cartes*
- üéØ ***Take Flight**: Enchanted creature gets +1/+0 and has flying and "Whenever this creature attacks, draw a card."*

Under the hood, this functionality relies on modern **semantic embedding** techniques to represent both user queries and card descriptions as **vectors**. Semantic similarity between a query and a card is then simply evaluated by comparing the proximity of their respective vectors. The search operation can therefore be executed quickly and efficiently within the database.

üåç Bonus: the model understands multiple languages and does not require the use of technical or exact vocabulary.

üëâ No need to be a Magic rules expert to contribute to this project!

### Core Features

- **F1**: Knowledge Base Construction  üõ†Ô∏è
    - Download raw data files
    - Automatically generate a text description for each card
    - Convert to vector embeddings using an API
    - Insert into the database
- **F2**: Endpoints for browsing/exploring the database  üîé
    - `/cards/{id}` : retrieve a card by its unique ID
    - `/cards?name=...` : search by exact or partial name
    - `/cards/random` : get a random card (useful for testing or fun)
- **F3**: Semantic Search Engine üß†
    - Convert user query into a vector
    - Perform similarity search in the database
    - Display results
- **F4**: API and/or CLI Interface üíª

### Optional Features

The project can be extended in various directions depending on the group's interests.

::: {.callout-note collapse="true" title="Optimizing Semantic Search Performance üöÄ"}
- **FO1a**: Experiment with different string formats for card descriptions
  - (short) *[name] : [description]"*
  - (detailed) *"This is a MTG card with the name [name]. It costs [cost] to play. It is a [type]. It is described as follows: [description]. I has the following capacities: [...]"*
- **FO1b**: Contextualize by adding definitions for Magic-specific keywords to the input
    *e.g. "Scry N" = "look at the top N cards from your library and put any number on the bottom, and the rest back on top in any order"*
- **FO1c**: Build an evaluation dataset to measure performance
- **FO1d**: Implement reranking techniques to refine results
- **FO1e**: Try out different embedding models
:::


::: {.callout-note collapse="true" title="Extending to Other Data or Advanced Use Cases üß©"}
- **FO2a**: Search within a library of standard preconstructed decks
- **FO2b**: Search using thematic descriptions (e.g. "cards about dragons")
- **FO2c**: Search the game rules database
- **FO2d**: Build a virtual deck assistant, add/remove cards, check rules compatibility, show deck stats
:::


::: {.callout-note collapse="true" title="Improving Usability üé®"}
- **FO3a**: Combine semantic search with more traditional filters (color, type, cost, etc.)
- **FO3b**: Allow users to exclude specific cards from results
- **FO3c**: Include game format restrictions (e.g. banned cards)
- **FO3d**: Build a **simple** web interface
:::

### Tools & Technologies

- **Language**: Python
- **Version Control**: Git
- **Testing**: `pytest`
- **Database**: PostgreSQL + `pg_vector` extension
- **Backend API**: FastAPI
- **Frontend GUI** (optional, use a **well-known** framework):
  - Quick prototyping: Observable, Streamlit, Shiny, etc.
  - SPA client for the API: Vue3, React, Svelte, etc.
- **Knowledge database** : <https://mtgjson.com/>{target="_blank"}
- **Embedding API** : OpenWebUI on SSPCloud (<https://llm.lab.sspcloud.fr/>{target="_blank"})
</details>

::: {.callout-tip collapse="true" title="French version"}

### Pr√©sentation

**Magic: The Gathering** est un jeu de cartes populaire s'appuyant sur une m√©canique de constitution de son propre paquet (*deck building*). Avec plus de 50 000 cartes publi√©es depuis 1993, retrouver celle qu'il vous faut peut vite devenir un casse-t√™te... sauf si vous avez le bon outil !

üí° Les moteurs de recherche classiques vous permettent de filtrer par nom, couleur ou type, mais ce sont souvent les descriptions **textuelles** des cartes qui r√©v√®lent leur v√©ritable int√©r√™t. **MagicSearch** propose un moteur de **recherche s√©mantique** intelligent qui comprend vos requ√™tes en langage naturel, m√™me si vous ne connaissez pas le nom exact de la carte.

Exemple :
- üîé *Enchantement qui accorde le vol √† une cr√©ature et permet de piocher des cartes*
- üéØ ***Take Flight**: Enchanted creature gets +1/+0 and has flying and "Whenever this creature attacks, draw a card."*

Sous le capot, cette fonctionnalit√© s'appuiera sur la technique moderne de **plongement s√©mantique** (*embedding*) pour repr√©senter les requ√™tes des utilisateurs et la description textuelle de chaque carte par des **vecteurs**. La similarit√© s√©mantique entre requ√™te et description d'une carte se rapporte ainsi √† une simple √©valuation de la proximit√© des vecteurs les repr√©sentant. L'op√©ration de recherche peut donc √™tre effectu√©e rapidement et efficacement en BDD.

üåç Bonus : le mod√®le comprend plusieurs langues et ne n√©cessite pas d'utiliser un vocabulaire pr√©cis ou technique.

üëâ Pas besoin d'√™tre un expert en r√®gles de Magic pour contribuer √† ce projet.

### Fonctionnalit√©s de base

- **F1** : Construction de la base de connaissance üõ†Ô∏è
    - t√©l√©chargement d'un fichier de donn√©es brutes
    - g√©n√©ration automatique d'une description textuelle de chaque carte
    - transformation en vecteur via une API d'*embedding*
    - insertion en BDD
- **F2** : Endpoints de consultation/exploration de la base üîé
    - `/cards/{id}` : retrouver une carte par son identifiant unique
    - `/cards?name=...` : recherche par nom exact ou partiel
    - `/cards/random` : carte al√©atoire (utile pour tester ou s'amuser)
- **F3** : Recherche s√©mantique üß†
    - transformation de la requ√™te utilisateur en vecteur
    - recherche par similarit√© en BDD
    - pr√©sentation des r√©sultats
- **F4** : Interface API et/ou CLI üíª

### Fonctionnalit√©s optionnelles

Il est possible d'enrichir ces fonctionnalit√©s de diff√©rentes mani√®res en fonction des ap√©tences du groupe.

- **FO1a** : travail sur la cha√Æne de caract√®res repr√©sentant une carte
  - *[name] : [description]"* (version courte)
  - *"This is a MTG card with the name [name]. It costs [cost] to play. It is a [type]. It is described as follows: [description]. I has the following capacities: [...]"* (version plus pr√©cise)
- **FO1b** : contextualisation en ajoutant les d√©finitions de mots-clef sp√©cifique au jeu
    *par exemple: "Scry N" = "look at the top N cards from your library and put any number on the bottom, and the rest back on top in any order"*
- **FO1c** : √©valuation de la performance (constitution d'un jeu de donn√©e d'√©valuation)
- **FO1d** : m√©thode de *reranking* (r√©ordonnancement des r√©sultats √† partir de la requ√™te utilisateur)
- **FO1e** : experimentation de diff√©rents mod√®les d'*embedding*

---

- **FO2a** : recherche parmi une base de *decks* standards pr√©constitu√©s
- **FO2b** : recherche √† partir des descriptions th√©matiques des cartes
- **FO2c** : recherche de r√®gles du jeu
- **FO2d** : assistant de cr√©ation d'un paquet "virtuel": ajouter / retirer une carte, v√©rifier les r√®gles, afficher des statistiques

---

- **FO3a** : combiner recherche s√©mantique avec des filtres plus classiques sur les caract√©ristiques des cartes
- **FO3b** : possibilit√© d'√©carter certaines cartes de la recherche
- **FO3c** : prise en compte du "format de jeu" qui interdit certaines cartes
- **FO3d** : interface web **simple**


### Conseils / Outils

- **Langage** : Python
- **Gestion de version** : Git
- **Tests** : `pytest`
- **Base de donn√©es** : PostgreSQL + extension `pg_vector`
- **Backend API** : FastAPI
- **Frontend GUI** (optionnel, utiliser un framework **d√©j√† bien ma√Ætris√©**) :
  - Prototypage rapide: Observable, Streamlit, Shiny, etc.
  - SPA client de l'API: Vue3, React, Svelte, etc.
- **Knowledge database** : <https://mtgjson.com/>{target="_blank"}
- **API d'*embedding*** : OpenWebUI sur le SSPCloud (<https://llm.lab.sspcloud.fr/>{target="_blank"})


:::




## Cr√©ez votre propre serveur de poker üÇ±

Tuteur : Lucas Bouju 

### Pr√©sentation

L'objectif de ce projet est de cr√©er un serveur de poker permettant d'hoster des tables et jouer des parties de texas hold'em poker.
Votre serveur communiquera avec les utilisateurs √† l'aide d'HTTP, et utilisera une base de donn√©es postgresql pour sauvegarder les informations des joueurs.

### Fonctionnalit√©s de base

- F1 : En tant que joueur identifi√©, je peux rejoindre une table o√π il reste de la place pour d√©marrer un cash game
- F2 : En tant que joueur sur une table, je peux participer √† la partie lorsque c'est mon tour 
- F3 : En tant que serveur de poker, je garantis le respect des r√®gles du jeu de poker
- F4 : En tant qu'admin du serveur, je peux cr√©diter les portefeuilles des joueurs 

### Fonctionnalit√©s optionnelles

- FO1 : Cr√©ation d'un client pour joueur en CLI
    - cr√©ation d'un nouveau compte
    - identification par mot de passe
    - jouer une partie
    - envoi de r√©f√©rence de virement √† l'administrateur pour un renflouage plus rapide
- FO2 : Ajout de modes de jeu suppl√©mentaires
    - Mode tournoi
    - Omaha, Bomb pot
    - Multiples showdown : "running it twice"
- FO3 : Fonctionnalit√©s avanc√©es
    - identification par mot de passe
    - suivi des statistiques des joueurs au fil du temps
    - impossiblit√© de rejoindre une partie √† moins d'√™tre big blind ou de la payer
    - ajout de bots pour jouer m√™me lorsque personne n'est connect√©
- FOX : La fonctionalit√© dont vous avez toujours r√™v√© mais qui n'a jamais √©t√© impl√©ment√©e sur les sites de poker en ligne

### Conseils / Outils

Les r√®gles du jeu sont accessibles ici :

- [Wikipedia](https://en.wikipedia.org/wiki/Texas_hold_%27em){target="_blank"}
- [California State Justice Dpt](https://oag.ca.gov/sites/all/files/agweb/pdfs/gambling/BGC_texas.pdf){target="_blank"}


## QR Code Tracking

Tuteur : Thierry Math√©

### Pr√©sentation

Ce projet a pour but de cr√©er une interface de programmation d'application Web (ou API web) permettant la cr√©ation de QR code et le suivi de leurs utilisations.

Une API Web est une interface qui permet √† une application dite "cliente" d'acc√©der √† des services offerts par une autre application. Les API pr√©sentent un point d'acc√®s (ou endpoint) pour chaque service offert. Voici quelques exemples de services: obtenir des horaires de train, calculer un itin√©raire... 

Les √©changes se font via le protocole HTTP. L'application cliente envoie une requ√™te HTTP vers un endpoint de l'API, l'API transmet la requ√™te √† l'application sous jacante et renvoie la r√©ponse fournie au client. 

Ce projet √† donc pour but de cr√©er une application permettant la cr√©ation de QR code et le suivi de leurs utilisations puis de l'associer √† une API afin que des applications clientes puissent l'utiliser via le web. 
 
Les QR Code font maintenant parti de notre quotidien. Ces pictogrammes permettent de stocker des informations textuelles ou num√©riques. En plus de la cr√©ation de QR code l'application √† cr√©er devra √™tre capable d'en suivre l'utilisation.

Ce suivi concerne uniquement les QR code permettant d'acc√©der √† un site internet. Le QR code g√©n√©r√© ne contiendra pas l'adresse du site en question mais l'adresse d'un endpoint sp√©cifique de l'API qui m√©morisera l'appel puis redirigera l'utilisateur vers le site voulu. Ce suivi permet de mesurer l'utilisation du QR code.


### Fonctionnalit√©s de base

Chaque fonctionnalit√© correspond √† un "endpoint" de l'API √† cr√©er:

- F1 : G√©n√©re un QR code simple √† partir du texte donn√©e (accessible √† tous)
- F2 : Cr√©er un compte utilisateur (accessible √† tous)
- F3 : Cr√©er un QR code suivi √† partir d'une URL donn√©es (authentification n√©cessaire)
- F4 : Reception des QR code suivis et redirection (accessible √† tous)
- F5 : Acc√©der aux donn√©es de suivi d'un QR suivi (authentification n√©cessaire). A minima les informations sont la date et l'heure d'utilisation.

### Fonctionnalit√©s optionnelles

- FO1 : Authentification par jeton
- FO2 : Cr√©ation de QR code personnalisables (couleur, ajout de logo...)
- FO3 : Ajout d'autres informations de suivi (adresse IP d'appel, toutes autres informations pr√©sentes dans l'ent√™te http)



## √Ä Port√©e De Verre : gestion de bar personnel et suggestion de cocktails

Tuteur : Elwenn Joubrel 

### Pr√©sentation

Ce projet vise √† cr√©er une application pratique et ludique destin√©e √† la pr√©paration de cocktails. √Ä partir des ingr√©dients qu'ils ont √† disposition, les utilisateurs peuvent d√©couvrir les recettes de cocktails qu'ils sont d√©j√† en mesure de r√©aliser, ou celles pour lesquelles il ne manque que quelques √©l√©ments.

En pratique, le projet repose d'abord sur le d√©veloppement d'une API REST exploitant des recettes provenant de l'API publique TheCocktailDB, qui fournit les compositions, instructions et visuels de centaines de cocktails.

L'application permet √† tout utilisateur d'interroger l'API (depuis un client CLI ou HTTP) pour rechercher des recettes, avec possibilit√© de filtrer les r√©sultats. Un utilisateur authentifi√© peut en compl√©ment enregistrer les ingr√©dients disponibles dans son stock personnel. √Ä partir de cette information, l'API propose :
* les recettes r√©alisables imm√©diatement‚ÄØ;
* les recettes proches, n√©cessitant un nombre limit√© d'ingr√©dients suppl√©mentaires.

Dans sa version la plus simple, l'application n'aura pas besoin d'un client et se contentera parfaitement de endpoints d'API soigneusement document√©s.

### Fonctionnalit√©s de base

- F1 : Tout visiteur peut rechercher des recettes, en particulier avec filtrage (alcoolis√© ou non, par cat√©gorie, etc.)
- F2 : Un visiteur peut cr√©er un compte, puis s'authentifier par mot de passe
- F3 : Un utilisateur peut ajouter, supprimer et consulter les ingr√©dients dont il dispose 
- F4 : L'application peut proposer √† un utilisateur la liste des cocktails qu'il peut r√©aliser imm√©diatement
- F5 : Elle propose √©galement les recettes pour lesquelles il manque peu d'ingr√©dients

### Fonctionnalit√©s optionnelles

- FO1 : Cr√©ation et gestion de recettes priv√©es, ind√©pendantes de TheCocktailDB
- FO2 : Choix de cocktails √† mettre en favoris, avec ajout de notes personnalis√©es
- FO3 : G√©n√©ration d'une liste de courses optimis√©e en identifiant les ingr√©dients √† acheter en priorit√© pour maximiser le nombre de nouvelles recettes r√©alisables
- FO4 : D√©veloppement d'un client simple, CLI ou GUI au choix
- ...
- FOX : Vous pouvez √©videmment laisser libre cours √† votre imagination et impl√©menter les fonctionnalit√©s qui vous int√©ressent (multi-utilisateur, mode anti-gaspi, recherches avanc√©es, etc.)

### Conseils / Outils ...

- **Langage** : Python
- **Outil de versionnage** : Git
- **Base de donn√©es** : PostgreSQL
- **Backend API** : FastAPI
- **Frontend** (Attention, l'accompagnement sera limit√© selon le framework choisi) : 
    - **CLI** : `InquirerPy`
    - **GUI** : En python (`tkinter`, `streamlit`, `reflex`, etc.) ou HTML/JS/CSS (React, Vue, etc.) selon votre app√©tance
- **Tests** : `pytest`
- **Linting** : `ruff`


## Cr√©ez votre propre application de sport

Tuteur : Samuel GOUTIN

### Pr√©sentation

Strava est un r√©seau social utilis√© pour enregistrer et partager ses activit√©s sportives. Beaucoup de fonctionnalit√©s sont payantes et d'autres pas au go√ªt de chacun. Ce projet vise √† cr√©er une alternative √† Strava, mais en mieux !

Concr√©tement, le projet prendra la forme d'une API qui s'appuiera sur une base de donn√©es pour persister des informations et sur une interface graphique pour la pr√©sentation.

### Fonctionnalit√©s de base

- F1 : Un utilisateur doit pouvoir :
    - cr√©er une activit√© en chargeant un fichier gpx,
    - consulter ses activit√©s avec possibilit√© d'appliquer un ou deux filtres,
    - modifier ou supprimer une activit√©.
- F2 : Un utilisateur doit pouvoir acc√©der √† un fil d'actualit√© listant les activit√©s de tous les utilisateurs qu'il suit.
- F3 : Un utilisateur doit pouvoir liker et commenter l'activit√© d'un utilisateur qu'il suit.
- F4 : Un utilisateur doit pouvoir acc√©der √† des statistiques le concernant :
    - nombre d'activit√©s par semaine et par sport,
    - nombre de kilom√®tres parcouru par semaine,
    - nombre d'heures d'activit√© par semaine.

### Fonctionnalit√©s optionnelles

- FO1 : Un utilisateur doit pouvoir visualiser (via barplots, calendar heatmap, ou autre) ses statistiques d√©finis en **F4**.
- FO2 : Un utilisateur doit pouvoir visualiser le trac√© de ses activit√©s sur une carte.
- FO3 : Un utilisateur doit pouvoir :
    - cr√©er un parcours √† partir d'une adresse de d√©part et d'arriv√©e,
    - visualiser le parcours sur une carte,
    - t√©l√©charger la trace gps du parcours.
- FO4 : Un utilisateur doit pouvoir acc√©der √† des pr√©dictions sur des distances inconnues √† partir de ses activit√©s.

### Conseils / Outils ...

- Outils : FastAPI (webservice), sqlite (base de donn√©es), streamlit (interface graphique)
- Qui dit utilisateur dit authentification : optez pour une authentification HTTP basique
- Les indications sont parfois incompl√®tes de mani√®re laisser de la place √† votre imagination et √† votre bon sens


## Ub'EJR Eats

Tutor: Cl√©ment Valot 

### Abstract

The EJR's famed galette-saucisse is now the most sought-after delicacy in all of Rennes!
To keep up with the increasing demand, the EJR has tasked you with delivering a back-end application to help with the orders and deliveries.

### Features

- F0: Provide secure authentication
- F1: As the EJR administrator, I can store and expose an editable menu with various items and prices
- F2: As an EJR customer, I can pick items from the menu to place an order after providing an address in Rennes 
- F3: As an EJR delivery driver, I am provided with a map and itinerary for the next deliveries

### Optional Features

- OF1 : Include bundles (e.g. main course + drink for a small discount), discounts, and limited availability in the menu. Difficulty :star: 
- OF2 : Automate the delivery process so that the delivery driver is automatically notified once a certain amount of orders have been placed, or a certain amount of time elapsed since the last order has been placed. Difficulty :star: :star:
- OF3 : Integrate with a payment system (e.g. Stripe). Difficulty :star: :star: :star: 

### Specifications 
- Python PDM project (Template provided)
- PostGreSQL database
- FastAPI interface (To be tested with an API client)
- Integration with Google Maps API
