---
title: "POO, Git et Tests Unitaires"
description: "TP 1"
author: "R√©mi P√©pin, Ludovic Deneuville"
format:
  html:
    toc: true
    toc-location: left
    toc-expand: 3
from: markdown+emoji
number-sections: true
---

::: {.callout-important}
Les TP sont pr√©vus pour √™tre r√©alis√©s en √©tant connect√© √† votre [**VM ENSAI**]{.underline}, soit depuis les clients l√©gers des salles info, soit via <https://view.ensai.fr/>{target="_blank"}. Vous y disposez de tous les outils n√©cessaires :

- `Python 3.10` : la version de Python install√©e √† l'ENSAI
  - ainsi que les packages n√©cessaires
- `Visual Studio Code` : votre √©diteur de code
- `Git` : pour g√©rer vos d√©p√¥ts
- `PostgreSQL` : une base de donn√©es
  - `DBeaver` : pour consulter, modifier cette base de donn√©es

√Ä moins que vous ne ma√Ætrisiez des outils tels [Docker](https://www.docker.com/){target="_blank"} pour cr√©er votre base de donn√©es, il est fortement d√©conseill√© de coder sur votre propre machine que ce soit en TP ou en projet. Vous allez perdre un temps consid√©rable en installation et configuration. Et m√™me si vous √™tes tr√®s tr√®s dou√©s certaines parties ne pourront de toute mani√®re pas fonctionner.
:::



## √Ä faire √† la maison {.unnumbered}

Un pr√©requis de ce TP est que votre configuration `Git` soit op√©rationnelle.

::: {.callout-tip}
Si vous avez besoin de vous rafr√Æchir la m√©moire sur Git, suivez ce [lien](https://ludo2ne.github.io/Git-tuto/doc/tp-ensai.html){target="_blank"}.
:::

#### Compte GitHub {.unnumbered}

- [ ] Cr√©ez un compte [GitHub](https://github.com/){target="_blank"}, si vous n'en avez pas d√©j√† un

#### Config Git {.unnumbered}

- [ ] Ouvrez Git Bash
- [ ] Ex√©cutez cette commande : `git config -l`

Si les valeurs *user.name* et *user.email* sont bien renseign√©es, tout est ok.

Si ce n'est pas le cas, ex√©cutez les [5 commandes git config](https://ludo2ne.github.io/Git-tuto/doc/tp-ensai.html#configuration){target="_blank"}.

#### Cl√© SSH {.unnumbered}

- [ ] Ex√©cutez cette commande : `cat ~/.ssh/id_rsa.pub` (toujours dans Git Bash)

Si le fichier existe et que cela renvoie un r√©ultat commen√ßant par *ssh-rsa*, cela signifie que vous avez bien d√©fini une cl√© SSH sur votre machine.

Dans le cas contraire, [cr√©ez une cl√© SSH](https://ludo2ne.github.io/Git-tuto/doc/tp-ensai.html#cr%C3%A9ation-dune-cl%C3%A9-ssh){target="_blank"}

Nous allons maintenant v√©rifier si vous avez bien d√©clar√© cette cl√© publique sur GitHub, ou sinon l'ajouter

- [ ] Copiez la cl√© publique : `cat ~/.ssh/id_rsa.pub | clip`
- [ ] Allez sur la [page pour d√©clarer une nouvelle cl√© SSH](https://github.com/settings/ssh/new) (Settings > SSH and GPG keys > New)
  - Title : VM ENSAI
  - Key : Collez votre cl√©
  - [Add SSH key]{.green-button}

Soit votre cl√© publique est maintenant d√©clar√©e √† GitHub, ou au pire, GitHub vous dira qu'il connait d√©j√† cette cl√©.  


## Objectifs {.unnumbered}

Les objectifs de ce premier TP sont les suivants :

- Utilisation de *Git*
- Remise en jambe *Python* et *POO*
- √âcriture de *Tests Unitaires* avec *pytest*

Ce TP m√™le explications et phases de code.  

Les explications de ce TP ne doivent pas prendre le pas sur celles de votre intervenant. Prenez les comme une base de connaissance pour plus tard, mais pr√©f√©rez toujours les explications orales.


## Cr√©ation des d√©p√¥ts

::: {.callout-note}
Pour ce premier TP, vous allez [**travailler avec votre √©quipe projet**]{.underline} sur un seul et m√™me d√©p√¥t distant.

Un membre de l'√©quipe va cr√©er un d√©p√¥t sur GitHub et ensuite tous les membres (le cr√©ateur du d√©p√¥t GitHub inclus) vont cr√©er leurs d√©p√¥t locaux en clonant ce d√©p√¥t distant.
:::

### Le d√©p√¥t distant

::: {.callout-important}
Un seul membre de l'√©quipe cr√©e ce d√©p√¥t distant.
:::

- [ ] Connectez-vous sur [GitHub](https://github.com/){target="_blank"}
- [ ] Cr√©ez un *fork* du d√©p√¥t [ENSAI-2A-complement-info-TP](https://github.com/ludo2ne/ENSAI-2A-complement-info-TP){target="_blank"}
  - Un fork est une copie d'un d√©p√¥t, permettant √† un utilisateur de d√©velopper ind√©pendamment sans affecter l'original
- [ ] Ajoutez les membres de votre √©quipe
  - Sur la page du d√©p√¥t > :gear: Settings > Collaborators > [Add people]{.green-button}
- [ ] Envoyez √† vos camarades, l'adresse du d√©p√¥t distant


### Les d√©p√¥ts locaux

Maintenant, chaque membre de l'√©quipe va cr√©er sur sa propre machine, son clone du d√©p√¥t.

Commen√ßons par cr√©er un dossier pour ranger votre d√©p√¥t local :

- [ ] Ouvrez *Git Bash*
- [ ] Ex√©cutez cette commande : `mkdir -p /p/Cours2A/UE3_Complements_info/TP1 && cd $_`
  - elle cr√©e l'arborescence demand√©e (*mkdir*)
  - puis elle vous positionne dans ce dossier (*cd*)
- [ ] Clonez le d√©p√¥t distant avec SSH
  - Lorsque vous √™tes sur la page GitHub du d√©p√¥t, cliquez sur [Code]{.green-button}, puis sur l'onglet SSH
  - Copiez l'url qui commence par `git@github.com...`
  - Dans Git Bash : `git clone <url>` (en rempla√ßant \<url\>)

Votre clone est pr√™t, vous pouvez v√©rifier sa pr√©sence via l'explorateur Windows (WIN + E, puis allez dans le dossier `P:\Cours2A\UE3_Complements_info\TP1`).

- [ ] Fermez *Git Bash*
  - Si tout s'est bien pass√©
  - Vous allez retrouver ensuite le m√™me Git Bash, qui est int√©gr√© dans VS Code 


## Visual Studio Code

### Ouvrir le d√©p√¥t

Un d√©p√¥t est un ensemble de dossiers et de fichiers. Pour consulter et √©diter ces fichiers, vous allez utiliser [Visual Studio Code](https://ludo2ne.github.io/ENSAI-2A-remise-a-niveau/docs/outils/VSCode.html){target="_blank"}, un √©diteur tr√®s populaire.

::: {.callout-note}
Au lieu de VS Code, vous pouvez tout √† fait ouvrir vos fichiers avec le *bloc-notes*, mais vous vous rendrez rapidement compte que c'est beaucoup moins pratique.
:::

- [ ] Ouvrez Visual Studio Code
- [ ] Ouvrez votre d√©p√¥t local
  - File > Open Folder
  - Allez dans le dossier `P:\Cours2A\UE3_Complements_info\TP1`
  - Cliquez une seule fois sur :file_folder: ENSAI-2A-complement-info-TP, puis sur le bouton [S√©lectionner un dossier]{.grey-button}

::: {.callout-important}
- [ ] V√©rifiez que le dossier parent dans l'Explorer VS Code est *ENSAI-2A-complement-info-TP*
  - L'Explorer, √† gauche, permet d'explorer l'arborsence des fichiers et dossiers
  - :warning: Si le dossier parent n'est pas le bon, recommencez l'*Open Folder* o√π vous aurez de gros soucis par la suite !!! 
:::

### Contenu du d√©p√¥t

Ce d√©p√¥t contient les √©l√©ments suivants :


| √âl√©ment             | Description                                                                                   |
|---------------------|-----------------------------------------------------------------------------------------------|
| `.vscode`           | Contient les param√®tres VS Code pour ce projet                                                |
| `src`               | Dossier contenant les fichiers Python rang√©s dans une arborescence respectant la programmation en couches           |
| `.gitignore`        | Liste des fichiers √† ne pas versionner avec git                                               |
| `LICENSE`           | D√©finit les droits d‚Äôutilisation du d√©p√¥t                                                     |
| `README.md`         | Contient des informations utiles pour pr√©senter, installer et utiliser l‚Äôapplication          |
| `requirements.txt`  | Liste les packages Python n√©cessaires                                                         |


### La config VS Code

::: {.callout-tip}
VS Code est hautement param√©trable, aussi bien au niveau User qu'au niveau Workspace (i.e. consid√©rons que Workspace = d√©p√¥t).
:::

- [ ] Ouvrez le fichier `.vscode/settings.json`

Ce fichier contient du param√©trage pour le d√©p√¥t, par exemple :

- Le formattage automatique lorsque vous sauvegardez un fichier Python
  - Le formateur utilis√© est [Black](https://black.readthedocs.io/){target="_blank"}
  - La taille des lignes est limit√©e √† 100 caract√®res
  - Les tabulations sont remplac√©es par 4 espaces
- Le dossier source se nomme `src`
  - Pour importer des modules, ce dossier *src* sera la racine
- le terminal par d√©faut est *Git Bash*


## Git

::: {.callout-note}
Vous allez maintenant faire quelques manipulations basiques avec Git :

- Ajouter des fichiers au d√©p√¥ts
- Cr√©er des points de sauvegarde
- Envoyer vos modifications locales vers les d√©p√¥ts distant
- Mettre √† jour votre d√©p√¥t local
:::

### Routine Git

- [ ] Ouvrez le *Git Bash* int√©gr√© dans VS Code
  - Terminal > New Terminal (ou CTRL + √π)
- [ ] Lancez le programme principal pour v√©rifier que tout fonctionne bien
  - `python src/__main__.py`
- [ ] Cr√©ez un nouveau fichier dans le dossier *src* en compl√©tant avec votre propre pr√©nom et collez ce code
  ```{.python filename="<prenom>.py"}
  a, b = 0, 5

  for i in range(b):
      print(" " * a, end="")
      a += 1
      print("Bonjour <prenom>")
  ```
- [ ] Dans Git Bash, utilisez les commandes *status*, *add*, *commit*, *push* et *pull* pour envoyer vos modifications vers le d√©p√¥t distant

::: {.callout-tip collapse="true" title="Aide"}
[L'enchainement des commandes Git](https://ludo2ne.github.io/Git-tuto/doc/tp-ensai.html#add-commit-pull-et-push){target="_blank"} devra devenir un automatisme.

Si lors du *push*, vous avez ce message, c'est qu'il faut commencer par *pull*.
```{.txt}
To https://github.com/ludo2ne/ENSAI-2A-complement-info-TP.git
Merge branch 'main' of https://github.com/ludo2ne/ENSAI-2A-complement-info-TP
 ! [rejected]        main -> main (fetch first)
error: failed to push some refs to 'https://github.com/ludo2ne/ENSAI-2A-complement-info-TP.git'
hint: Updates were rejected because the remote contains work that you do
hint: not have locally. This is usually caused by another repository pushing
hint: to the same ref. You may want to first merge the remote changes (e.g.,
hint: 'git pull') before pushing again.
hint: See the 'Note about fast-forwards' in 'git push --help' for details.
```
:::

### R√©soudre un conflit

- [ ] Pour tous les fichier `<prenom.py>`, [un seul membre]{.underline} de l'√©quipe commence par modifier le prenom dans le code
  - ne pas modifier les noms des fichiers, uniquement le code √† l'int√©rieur
    - `print("Bonjour <prenom>")` :arrow_right: `print("Bonjour Marie-<prenom>")`
  - Et il *add*, *commit* et *push*
- [ ] Ensuite les autres membres modifient chacun leur propre fichier
  - `print("Bonjour <prenom>")` :arrow_right: `print("Bonjour Anne-<prenom>")`
  - Et ils *add*, *commit* *pull* et *push*

Normalement un conflit survient lors du *pull*. En effet il y a un conflit de version

| Version                      | Code                                      |
|------------------------------|-------------------------------------------|
| Version originale            | `print("Bonjour <prenom>")`               |
| Votre modification           | `print("Bonjour Anne-<prenom>")`          |
| Version sur le d√©p√¥t distant | `print("Bonjour Marie-<prenom>")`         |

```{.python}
<<<<<<< HEAD
print("Bonjour Anne-<prenom>")          # Votre modification - current change
=======
print("Bonjour Marie-<prenom>")         # La modification du d√©p√¥t distant - incoming change
>>>>>>>
```

- [ ] Vous choisissez d'imposer votre version
  - Soit en cliquant sur *Accept Current Change
  - Soit en supprimant `print("Bonjour Marie-<prenom>")`, ainsi que les `<<<<<<<`, `=======` et `>>>>>>>`
- [ ] *add*, *commit* *pull* et *push*

::: {.callout-important}
Avoir un conflit, ce n‚Äôest pas grave !
Avoir un conflit, ce n‚Äôest pas grave !
Avoir un conflit, ce n‚Äôest pas grave !

Conflit ‚â† Erreur

Cela arrive simplement quand Git rencontre 2 versions et il n‚Äôa pas de :crystal_ball:, ni de :game_die: pour choisir laquelle est la bonne.

Pour √©viter les conflits, organisez-vous avec votre √©quipe pour √©viter autant que possible de travailler sur les m√™mes fichiers en m√™me temps.
:::


## Python et POO

### Ce que vous allez coder

Notre jeu s'inspirera de *Pok√©mon Unite* (aucune connaissance du jeu, ni de *Pok√©mon* n'est n√©cessaire).

Pour r√©sumer en quelques mots, il y aura des *Pokemons* qui s'affronteront lors de *Battles* en lan√ßant des *Attacks*. Voici les principaux objets que vous allez manipuler :

- `Pokemon` : qui ont diverses caract√©ristiques et statistiques
  - un nom
  - un niveau
  - [un type](https://www.nationhive.com/fr/jeux/pokemon-unite/guide/roles-des-pokemon){target="_blank"}
    - ici les types sont : Attaquant, D√©fenseur, Polyvalant, Soutient et Rapide (et non pas : Feu, Eau, Plante...)
  - des statistiques contenues dans un objet *Statistic* d√©fini ci-dessous
- `Statistic` : pour √©viter de surcharger la classe `Pokemon`, leurs stats sont stock√©es dans un objet de la classe `Statistic`
  - hp : health points
  - attack, defense, speed... : qui serviront d√©terminer la force de ses attaques
- `Attack` : diff√©rents types d'attaques dont disposeront les Pok√©mons (partie 3)
- `Battle` : servira √† faire s'affronter 2 Pok√©mons pour d√©terminer l'issue du combat (partie 4)

Et voici un diagramme de classe tr√®s simplifi√© des classes principales √† coder lors de ces quatres TP.

```{mermaid}
classDiagram
  class Pokemon {
    # _name : str
    # _level : int
    # _type : str
    # _current_stat : Statistic
    + get_pokemon_attack_coef() float
  }
 
  class Statistic {
    - __hp : int
    - __attack : int
    - __defense : int
    - __sp_atk : int
    - __sp_def : int
    - __speed : int
  }

  class Attack{
    # _name : str
    # _power : int
    # _description : str
    + compute_damage(Pokemon, Pokemon) int
  }

  class Battle{
    - first_monstie : Pokemon
    - second_monstie : Pokemon
    - winner : Pokemon
  }

  Pokemon --> Statistic : possesses
  Pokemon --> Attack : uses
  Battle ..>"2" Pokemon : call
```















---

:construction:

---




Vous allez cr√©er les **objets m√©tier** pour un jeu *Pok√©mon*.  
Un objet m√©tier repr√©sente dans votre code quelque chose de concret, qui mod√®lise la r√©alit√©.

> **Objet m√©tier (business object)** : repr√©sentation informatique d'un objet "r√©el" que notre programme va manipuler pour r√©pondre √† un besoin. Dans le cas de notre application cela sera des *Pok√©mons*, des attaques ou des objets.  
> Dans une application de e-commerce par exemple, les articles et comptes sont des objets m√©tier. Ils permettent de s√©parer les donn√©es de l'application et les traitements. Cela conduit √† avoir des objets contenant essentiellement des attributs et tr√®s peu de m√©thodes autre que des *getter* et *setter*.

Ce TP sera r√©alis√© avec l'IDE (**I**ntegred **D**evelopment **E**nvironment) `Visual Studio Code`.

### Importez le code du TP

* Ouvrez **Git Bash**
* Cr√©ez un dossier pour stocker le code du TP
  * par exemple, copiez la ligne ci-dessous, puis collez l√† dans Git Bash (clic droit > Paste)
  * `mkdir -p /p/Cours2A/UE3_Complements_informatique/TP/TP1 && cd $_`
* Clonez le d√©p√¥t
  * `git clone https://github.com/ludo2ne/ENSAI-2A-complement-info-TP.git`
* Ouvrez **Visual Studio Code**
  * File > Open Folder
    * Aller dans `/p/Cours2A/UE3_Complements_informatique/TP/TP1/` (ou dans le dossier o√π se situe le d√©p√¥t que vous venez de cloner)
    * cliquer sur  `ENSAI-2A-complement-info-TP`, puis sur le bouton **S√©lectionner un dossier**
	* :warning: c'est tr√®s important de suivre tr√®s pr√©cis√©ment ces consignes, sinon vous risquez d'avoir des soucis d'import !

Lisez le fichier `README.md` et suivez les instructions.
Puis lancez le programme **__main__.py** pour vous assurer que tout fonctionne correctement.

* Ouvrez un terminal dans VSCode (CTRL + √π)
  * c'est le m√™me terminal **Git Bash** que vous avez ouvert au d√©but
  * mais c'est plus pratique d'avoir tout au m√™me endroit
* listez les branches `git branch -a`

Vous avez la possibilit√© de consulter la correction en changeant de branche si et seulement si vous √™tes bloqu√© trop longtemps.  
Voici quelques commandes git utiles :

```git
# Avant de changer de branches, cr√©ez un point de sauvegarde de votre travail
git add .
git commit -am "<message>"

# changer de branche
git checkout <nouvelle_branche>      # dans le terminal, la branche courante est indiqu√©√©e entre ()
git checkout -                       # pour retourner √† la branche pr√©c√©dente
```


## Mod√©lisation et impl√©mentation

> Dans un premier temps, nous allons coder uniquement les `Pokemons` (la classe `Statistic` est d√©j√† cod√©e).
> En fonction de son type, son coefficient d'attaque d√©pendra de diverses statistiques.

```{mermaid}
classDiagram
 class Pokemon {
 - __type : String
 - __current_stat : Statistique
 + get_pokemon_attack_coef() float
 }
 
 class Statistic {
 - __hp : int
 - __attaque : int
 - __defense : int
 - __spe_atk : int
 - __spe_def : int
 - __vitesse : int
 }
 Pokemon --> Statistic : poss√®de
```

Avant d'√©crire du code, nous allons r√©fl√©chir √† la meilleure conception possible pour r√©aliser nos Pok√©mons. Notre conception essaiera au maximum de respecter la r√®gle suivante : **faible couplage, forte coh√©sion**.  

En d'autre termes nous allons essayer de faire :

* des classes **les plus disjointes possible** (*faible couplage*) pour qu'une modification dans une classe ne nous demande pas de modifier les autres
* tout en essayant d'avoir **les t√¢ches r√©alis√©es par une seule classe les plus li√©es possible** (*forte coh√©sion*).

### Premi√®re approche : le ¬´ `if/elif/else` ¬ª :skull:

Ouvrez le code, et observez la classe `Pokemon`. Nous nous interessons √† la m√©thode `get_pokemon_attack_coef()` qui va servir √† d√©terminer la puissance de l'attaque en fonction du type de *Pok√©mon*.

> * [ ] **Question 1 :** Expliquez pourquoi une impl√©mentation √† base de `if/elif/else` pour les types est une mauvaise id√©e ? Imaginez s'il y avait plusieurs blocs de code similaires dans notre application, et que nous devions ajouter un nouveau type.

---

### La puissance de la POO

Au lieu d'externaliser les comportements de nos *Pok√©mons*, nous allons mettre tous leurs comportements sp√©cifiques dans des classes filles d'une super classe `Pokemon`. Ceci est rendu possible gr√¢ce √† deux propri√©t√©s des objets en POO :

* **h√©ritage** : il est possible de sp√©cialiser une classe existante en modifiant son comportement, ou en ajoutant de nouveaux
* **polymorphisme** : deux fonctions peuvent avoir le m√™me nom mais avoir des comportements diff√©rents

En plus, comme chacun de nos *Pok√©mons* va forcement √™tre d'un type, aucun ne sera simplement de la classe `Pokemon`, cela nous permet de rendre cette classe *abstraite*. En d√©finissant clairement notre classe abstraite nous allons avoir :

* Un plan pour toutes les classes qui en h√©ritent. Cela √† pour avantages de :
  * Donner des informations sur la structuration du code  
  * Permettre de g√©n√©rer automatiquement les m√©thodes √† d√©finir
  * Limiter les bug. Si on oublie une m√©thode, le code plante au d√©marrage, ce qui √©vite des comportements non pr√©vus difficile √† d√©tecter
* Une **interface** unique pour tous les types de *Pok√©mons*. Quelque soit le type du *Pok√©mon*, il sera consid√©r√© comme un `AbstractPokemon` partout dans le code.

---

> * [ ] **Question 2** :
>   * [ ] transformez la classe `Pokemon` en classe abstraite `AbstractPokemon`
>     * renommez √©galement le fichier en `abstract_pokemon.py`
>   * [ ] transformez la m√©thode `get_pokemon_attack_coef()` en m√©thode abstraite
>   * [ ] cr√©ez les classes `Attacker`, `Defender` et `AllRounder` qui h√©ritent de `AbstractPokemon`
>   * [ ] dans ces 3 classes, impl√©mentez la m√©thode `get_pokemon_attack_coef()`

Pour vous aider, voici le diagramme de classe :

```{mermaid}
classDiagram
  class AbstractPokemon {
    <<abstract>>
    # _current_stat : Statistique
    # _level : int
    # _name : str
    +get_pokemon_attack_coef() :  float
  }
  
  class BattleService {
    +resolve_battle() Battle
  } 
 
  class Statistique {
    - __hp : int
    - __attaque : int
    - __defense : int
    - __spe_atk : int
    - __spe_def : int
    - __vitesse : int
   }
 
  AbstractPokemon <|-- Attacker
  AbstractPokemon <|-- Defender
  AbstractPokemon <|-- AllRounder
  AbstractPokemon --* Statistique
  BattleService ..>"2" AbstractPokemon : use
```

Vous devriez arriver √† une arborescence proche de celle-ci :

```
üì¶pokemon_unite_lite
 ‚î£ üìÇbusiness_object
 ‚îÉ ‚î£ üìÇpokemon
 ‚îÉ ‚îÉ ‚î£ üìúabstract_pokemon.py
 ‚îÉ ‚îÉ ‚î£ üìúattacker.py
 ‚îÉ ‚îÉ ‚î£ üìúdefender.py
 ‚îÉ ‚îÉ ‚îó üìúall_rounder.py
 ‚îÉ ‚îó üìú statistique.py
 ‚îó üìÇservice
   ‚îó üìúbattle_service.py
```

Pour faire une classe abstraite, utilisez le package `abc`.  
Voici, pour vous inspirer, un exemple de ce qui est attendu :

```python
# Fichier abstract_personnage.py
from abc import ABC, abstractmethod

class AbstractPersonnage(ABC):
    def __init__(self, phrase_attaque:str, phrase_defense:str) -> None:
        self._phrase_attaque = phrase_attaque
        self._phrase_defense = phrase_defense
       
    @abstractmethod # d√©corateur qui d√©finit une m√©thode comme abstraite
    def degat_attaque(self) -> int:
     pass

# Fichier magicien.py
from abstract_personnage import AbstractPersonnage
class Magicien(AbstractPersonnage):
    def __init__(self) -> None:
        super().__init__("Lance une boule de feu","Utilise une barri√®re magique" )
       
    def degat_attaque(self) -> int:
        # code pour calculer les d√©g√¢ts
        return 10
```

### Testez votre code

> * [ ] **Question 3** : Testez la m√©thode `get_pokemon_attack_coef()` pour les classes `AttackerPokemon` et `AllRounderPokemon`.  
> Pour lancer tous les tests du projet, ex√©cutez dans le terminal : `python -m unittest`

Pour cela vous allez utiliser le package `unittest` de python.  

Ce package permet de r√©aliser des tests unitaires dans des classes s√©par√©es. L'avantage par rapport √† `doctest`, c'est que les tests ne "polluent" pas vos classes, et qu'il est possible de *patcher* certains comportements des classes.  

Un exemple de test est donn√© dans la classe `testDefenderPokemon`. Pour rappel, un test se d√©compose en 3 parties :

* **GIVEN** : cr√©ation des objets n√©cessaires √† la r√©alisation du test
* **WHEN** : appel de la m√©thode √† tester
* **THEN** : v√©rification du r√©sultat

Les classes de test seront organis√©es de la mani√®re suivante, en reproduisant l'architecture de votre application :

```
üì¶pokemon_unite_lite
 ‚î£ üìÇbusiness_object
 ‚îÉ ‚î£ üìÇpokemon
 ‚îÉ ‚îÉ ‚î£ üìúabstract_pokemon.py
 ‚îÉ ‚îÉ ‚î£ üìúattacker.py
 ‚îÉ ‚îÉ ‚î£ üìúdefender.py
 ‚îÉ ‚îÉ ‚îó üìúall_rounder.py
 ‚îÉ ‚îó üìú statistique.py
 ‚î£ üìÇservice
 ‚îÉ ‚îó üìúbattle_service.py
 ‚îó üìÇtest
  ‚îó üìÇtest_business_object
      ‚îó üìÇtest_pokemon
        ‚î£ üìútest_abstract_pokemon.py
        ‚î£ üìútest_attacker_pokemon.py
        ‚î£ üìútest_defender_pokemon.py
        ‚îó üìútest_all_rounder_pokemon.py
```

---

:bulb: Probl√®mes d'imports

* V√©rifiez que le dossier parent dans l'explorer de VSCode (√† gauche) est : **ENSAI-2A-complement-info-TP**
  * Si c'est TP1 ou TP ou autre chose ce n'est pas bon !
  * Sinon refaites : File > open Folder
  * Cliquez une fois sur ENSAI-2A-complement-info-TP
  * Cliquez sur le bouton `S√©lectionner un dossier`
  * Si √ßa vous le demande, vous pouvez enregistrer vos modifications
* Pr√©f√©rez utiliser des chemins complets d'import plut√¥t que des chemins relatifs
  * la racine des chemins est param√©tr√©e au niveau du dossier `src`
  * donc cela donne par exemple : 
    *`from business_object.pokemon.abstract_pokemon import AbstractPokemon`
	* car le dossier `business_object` est bien dans le dossier `src`
* Cr√©ez des fichiers `__init__.py` (vide)
  * dans TOUS les dossiers que vous cr√©ez
  * c'est un peu p√©nible mais √ßa peut d√©bloquer la situation

---


> * [ ] **Question 4** : Pouvez-vous tester la m√©thode `level_up()` directement sur un `AbstractPokemon` ? Avez vous une id√©e comment faire ? (ne pas coder cette question)

---

## L'agr√©gation, l'autre fa√ßon d'ajouter de la souplesse dans le code

Maintenant que nos Pok√©mons sont faits, nous allons y ajouter les attaques.  

Notre syst√®me va devoir respecter certaines contraintes :

* Plusieurs types d'attaques vont coexister, chacune avec un mode de calcul de d√©g√¢ts diff√©rent :
  * Des attaques  √† d√©g√¢ts variables s√©par√©es en 2 types :
    * attaques "physiques" qui utilisent l'attaque et la d√©fense des Pok√©mons
    * attaques "sp√©ciales" qui utilisent l'attaque sp√© et la d√©fense sp√© des Pok√©mons
  * Des attaques √† d√©g√¢ts fixes qui font un nombre fixe de d√©g√¢ts.
* Un pok√©mon peut avoir plusieurs attaques et le type de l'attaque doit √™tre transparent pour le pok√©mon.

---

### Attaques √† d√©g√¢ts fixes

Nous allons commencer par les attaques √† d√©g√¢ts fixes. Comme il y aura un autre type d'attaques, toutes les attaques h√©riterons de la classe abstraite `AbstractAttack` d√©j√† cr√©√©e. Cette classe poss√®de la m√©thode abstraite `compute_damage()` qui devra √™tre impl√©ment√©e dans les classes filles.

```{mermaid}
classDiagram

  class AbstractAttack{
    <<abstract>>
    # _power : int
    # _name : str
    # _description : str
    + compute_damage(APkm, APkm)$  int
  }

   class FixedDamageAttack{
    + compute_damage(APkm,APkm )  int
   }
 
   AbstractAttack <|-- FixedDamageAttack
```

> * [ ] **Question 5** Impl√©mentez la classe `FixedDamageAttack`, ainsi que sa m√©thode `compute_damage()` qui retournera simplement la puissance (*power*) de l'attaque.  
> Cr√©ez des tests pour v√©rifier que tout fonctionne correctement.

---

### Attaques √† d√©g√¢ts variables

Nous allons ensuite coder les attaques √† d√©g√¢ts variables. Elles utilisent la formule suivante :
```math
Damage = \big ( \frac{(\frac{2*Level}{5}+2)* Power *Att}{Def*50} +2\big) *random* other\_multipliers
```

avec :

* $Att$‚Äã : √©gal soit √† l'attaque ou l'attaque sp√© du Pokemon attaquant
* $Def$‚Äã‚Äã : √©gal soit √† la d√©fense ou d√©fense sp√© du Pokemon d√©fenseur
* $Power$‚Äã : la valeur de puissance de l'attaque
* $random$‚Äã‚Äã :une valeur comprise dans l'intervalle [0.85; 1]
* $other\_ multipliers$ : les autres multiplicateurs possibles, comme le coefficient d'attaque des pok√©mons.

La seule diff√©rence entre attaque physique et sp√©ciale vient des coefficients $Att$ et $Def$, le reste de la formule des d√©g√¢ts est identique. Nous allons donc utiliser le patron de conception *template method*, dont voici la mod√©lisation UML dans notre cas :

```{mermaid}
classDiagram

  class AbstractAttack{
    <<abstract>>
    # _power : int
    # _name : str
    # _description : str
    + compute_damage(APkm, APkm)$  int
  }

   class FixedDamageAttack{
    + compute_damage(APkm,APkm )  int
   }

  class AbstractFormulaAttack{
    <<abstract>>
    -get_attack_stat(APkm)$  float
    -get_defense_stat(APkm)$  float
    +compute_damage(APkm,APkm)  int
  }
 
  class PhysicalFormulaAttack{
    -get_attack_stat(APkm)  float
    -get_defense_stat(APkm)  float
  }
 
  class SpecialFormulaAttack{
    -get_attack_stat(APkm)  float
    -get_defense_stat(APkm)  float
  }
 
   AbstractAttack <|-- FixedDamageAttack
   AbstractAttack <|-- AbstractFormulaAttack
   AbstractFormulaAttack <|-- SpecialFormulaAttack
   AbstractFormulaAttack <|-- PhysicalFormulaAttack
```

La classe `AbstractFormulaAttack` va contenir :

* la m√©thode `compute_damage(pkmon_attacker: AbstratPokemon, pkmon_targeted: AbstractPokemon)`. Cette m√©thode va contenir la formule de calcul des d√©g√¢ts, mais en appelant les m√©thodes  `get_attaque_stat(AbstractPokemon)` et `get_defense_stat(AbstractPokemon)` pour savoir quelle statistique utiliser
* les m√©thodes abstraites `get_attack_stat(AbstractPokemon)` et `get_defense_stat(AbstractPokemon)`. Ces m√©thodes devront √™tre impl√©ment√©es dans les classes filles pour d√©terminer quelles statistiques utiliser.

> * [ ] **Question 6** : Impl√©mentez les 3 nouvelles classes et cr√©ez des tests pour v√©rifier que tout fonctionne correctement

---

## Architecture finale (bonus, si vous avez le temps)

Nous allons maintenant rattacher les bouts pour cr√©er notre architecture finale :

```{mermaid}
classDiagram
  class AbstractPokemon {
    <<abstract>>
    # _current_stat : Statistique
    # _level : int
    # _name : str
    # _attack_list : List~AbstractAttack~
    +get_pokemon_attack_coef()$  float
    +level_up() None
  }
 
  class Statistique {
    - hp : int
    - attaque : int
    - defense : int
    - spe_atk : int
    - spe_def : int
    - vitesse : int
  }
   
  class BattleService {
    + resolve_battle(APkm, APkm) : Battle
    + get_order(APkm, APkm)
    + choose_attack(APkm) : AAttack
  }  
  
  class Battle{
    - first_monstie : APkm
    - second_monstie : APkm
    - winner : APkm
    - rounds : List<Round>
  }

  class Round{
    attacker: APkm
    defender: APkm
    dealt_damage: int
    attack_description: str
  }
  BattleService ..>"2" AbstractPokemon : use
  AbstractPokemon <|-- Attacker
  AbstractPokemon <|-- Defender
  AbstractPokemon <|-- AllRounder
  Statistique *-- AbstractPokemon

  Battle .. BattleService
  Battle .. Round
 
  class AbstractAttack{
    <<abstract>>
    # _power : int
    # _name : str
    # _description : str
    +compute_damage(APkm, APkm)$ int
  }

  class FixedDamageAttack{
    + compute_damage(APkm,APkm )  int
  }

  class AbstractFormulaAttack{
    <<abstract>>
    -get_attack_stat(APkm)$  float
    -get_defense_stat(APkm)$  float
    + compute_damage(APkm,APkm ) int
  }
 
  class PhysicalFormulaAttack{
   -get_attack_stat(APkm)$  float
   -get_defense_stat(APkm)$  float
  }
 
  class SpecialFormulaAttack{
    -get_attack_stat(APkm)  float
    -get_defense_stat(APkm)  float
  }
 
  AbstractAttack <|-- FixedDamageAttack
  AbstractAttack <|-- AbstractFormulaAttack
  AbstractFormulaAttack <|-- SpecialFormulaAttack
  AbstractFormulaAttack <|-- PhysicalFormulaAttack
  BattleService >.. AbstractAttack  : use
  AbstractPokemon o-->"0..*" AbstractAttack

```

> * [ ] **Question 7** : Impl√©mentez le diagramme de classe ci-dessus et testez votre code en √©crivant de nouveaux tests unitaires.

Cette architecture permet de d√©corr√©ler les attaques des pok√©mons et de sp√©cifier le comportement des attaques au fur et √† mesure des h√©ritages. Les avantages sont :

* Pour la classe `AbstractPokemon`, toutes les attaques sont des `AbstractAttack`. Tant qu'elles exposent la m√©thode `compute_damage` notre programme va fonctionner. On peut ainsi facilement ajouter de nouveaux types d'attaques sans probl√®me.
* Un *Pok√©mon* peut avoir des attaques de tous les types
* Nous pouvons ajouter un syst√®me d'√©tat comme la paralysie ou le poison assez facilement. Il faut pour cela modifier la classe `AbstractAttack` et les classes qui en h√©ritent. Cela sera potentiellement long, mais ne demande pas de toucher √† la partie "*Pok√©mon*" de notre architecture.
* Une personne pourrait se concentrer sur la cr√©ation des *Pok√©mons* alors qu'une autre pourrait se concentrer sur celles des attaques sans difficult√©. Les deux parties du code sont relativement ind√©pendantes, la seule zone de couplage sont les classes `AbstractPokemon` et `AbstractAttack`, qui servent avant tout √† d√©finir ce qui doit √™tre fait par les classes filles et ce qui est accessible √† l'ext√©rieur.

Le fait d'externaliser le comportement des attaques dans des classes sp√©cifiques puis de les lier aux Pok√©mons via une relation d'agr√©gation assez souple qui permet de changer dynamiquement les attaques d'un Pok√©mon est le patron de conception *strategy*.
